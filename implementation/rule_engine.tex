The rule engine decides which rules may need to be executed while taking into
account rule priorities. The rule engine is composed of 3 data structures:

\begin{itemize}

   \item \emph{Rule Queue} is a bitmap representing the rules scheduled to run
      when the bit $i$ is set meaning that the rule $i$ is scheduled to run,
      which depends on fact availability (we have all the facts required to run
      a rule $i$). Rules are executed by order by fetching the least significant
      bit of the bitmap, unsetting that bit and then executing the corresponding
      rule. This operation is accomplished by using the \emph{bit scan
      forward (bsf)} assembly instruction available on x86/x86-64 machines;

   \item \emph{Rule Counter} is a counter of the number of predicates needed by
      the rule that exist in the database. For example, a rule \texttt{a, e(1)
      -o b} needs predicates \texttt{a} and \texttt{e} and the rule counter is
      thus at the most 2 (where the rule can be executed). The \emph{Rule Queue}
      bitmap is updated when the rule counter increments or decrements to/from
      the maximum possible value;

   \item \emph{Predicate Bitmap} is a bitmap representing the existence of facts
      for a given predicate in the database. When a predicate becomes available
      then the \emph{Rule Counter} is updated to take into account the existence
      of new facts.

\end{itemize}


\begin{figure}[t]
   \begin{center}
\begin{BVerbatim}[numbers=left,fontsize=\codesize]
a, e(1) -o b.  // Rule 1.
a -o c.        // Rule 2.
b -o d.        // Rule 3.
e(0) -o f.     // Rule 4.
c -o e(1).     // Rule 5.

a.
e(0).
\end{BVerbatim}
\end{center}
\vspace{5mm}
   \includegraphics[width=0.96\textwidth]{figures/implementation/rule_queue.pdf}

   \caption{Example program and corresponding rule engine data structures. The
      initial state is represented in (a), where the rules scheduled to run are
      1, 2 and 4. After attempting rule 1, bit 0 is unset from the \emph{Rule
      Queue}, resulting in (b). Figure (c) is the result of applying rule 2,
      \code{a -o c}, which marks rule 5 in the \emph{Rule Queue} since the rule
      is now \emph{available} in the \emph{Rule Counter}.}

   \label{fig:implementation:rule_engine}
\end{figure}

To better understand how our rule engine works, consider the
Fig.~\ref{fig:implementation:rule_engine} which shows the rules and the
corresponding rule engine data structures. Since we have facts for predicates
\texttt{a} and \texttt{e}, the \texttt{Rules Counter} starts with rules 1, 2 and
4 with 2, 1, 1 predicate counts. Since these rules have the required counter to
be applied, the \emph{Rule Queue} bitmap starts with the same three rules
(Fig.~\ref{fig:implementation:rule_engine}(a)). In order to pick rules for
execution, we take the rule corresponding to the least significant bit from the
\emph{Rule Queue} bitmap, initially the first rule \texttt{a, e(1) -o b}.
However, since we don't have fact \texttt{e(1)}, this rule fails and its bit in
\emph{Rule Queue} must be set to 0.
Figure~\ref{fig:implementation:rule_engine}(b) shows the rule engine data
structures at that point.

The next rule in \emph{Rule Queue} is the second rule \texttt{a -o c}.
Because the this rule succeeds, fact \texttt{a} is consumed and fact \texttt{c}
is derived. We thus update \texttt{Predicates Bitmap} accordingly, decreasing
the counters for the first and second rules in \emph{Rule Counter} since such
rules are no longer applicable (\texttt{a} was consumed), and increase the
counter for the fifth rule since \texttt{c} was derived. Finally, to update the
\emph{Rule Queue}, we must schedule the fifth rule since its counter has been
increased to the required number (we have all predicates).  In the continuation,
the rule engine will schedule the fourth and fifth rules to run.
Figure~\ref{fig:implementation:rule_engine}(b) shows the rule engine data
structures at that point.

Note that every node in the program has the same set of data structures
presented in Fig.~\ref{fig:implementation:rule_engine}. We use 64 bit integers
to implement the 2 bitmaps and an array of 16 bits integers for the \texttt{Rule
Counter}.

\subsubsection{Persistent Facts}

We do a small optimization to reduce the number of derivations of persistent
facts and, for that, we divide the program rules into two sets: \emph{persistent
rules} and \emph{non persistent rules}. Persistent rules are rules where only
persistent facts are involved. We compile such rules incrementally, i.e., we
attempt to fire all rules when a new persistent fact is derived. This is called
the \emph{pipelined semi-naive} evaluation and it originated in the P2
system~\cite{Loo-condie-garofalakis-p2}. This evaluation method avoids excessive
re-derivations of the same fact. The order of derivation does not matter for
those rules, since only persistent facts are used.

