In order to protect these important synchronization points, we use ticket
spin-locks. In Section~\ref{sec:data_structures} describes the locks used to
protect the node data structures. In addition to these locks, we also have a
lock per queue data structure that protects the thread's work queue.

In order to manipulate the state flag of each thread (see
Section~\ref{sec:implementation:parallelism}) we do not use locks but instead
manipulate the state flag using lock-free \emph{compare-and-swap} operations to
implement a state machine.

Finally, we summarize the synchronization hotspots by describing how the locks
are used in order to implement those hotspots.

\begin{description}

   \item \textbf{New Facts}: We use the node's \emph{Main Lock} and then attempt
      to lock the \emph{DB Lock}. If the \emph{Db Lock} cannot be used, then the
      new facts are added to the \emph{Fact Buffer}, otherwise the node data
      structure is updated with new facts. If the target node is not currently
      in any work queue, we lock the destination work queue and then add the
      node and change the state of the node to \textbf{active}. Finally, if the
      target thread that owns the target node is \textbf{idle}, we activate it
      by updating its state flag.

\item \textbf{Node Stealing}: For node stealing, we acquire the lock of the
   target thread's queue and then copy the stolen node pointers to a temporary
   buffer. For each node, we use the \emph{Main Lock} to update its
   \emph{Owner} attribute and then add it to the thread's work queue.

\end{description}
