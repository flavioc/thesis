The introduction of thread-based facts allows for explicit parallelism in a
language that is purely implicit. This introduces issues when attempting the
prove the correctness of programs because the behavior of threads and the
scheduling strategy is now also part of the program logic. Some of this behavior
is hidden from the programs because it is part of how coordination facts and
thread scheduling works on the virtual machine.

Consider the SBP program where we need to prove that the graph is correctly
partitioned into regions. To accomplish this, we need to know that the VM
initially randomly nodes to threads so that the code in
lines~\ref{line:threads:splash_part1}-\ref{line:threads:splash_part2} in
Fig.~\ref{code:threads:sbp} that performs the region-based partitioning actually
makes sense. Moreover, the behavior of coordination facts \code{set-thread} and
\code{just-moved} need to be part of the entire proof.

Fortunately, since linear logic is the foundation of LM, it is possible to model
the semantics of LM by using LM rules. In Chapter~\ref{chapter:implementation},
we have seen that threads and nodes transition between different states during
execution and we are going to model that. We define the following node
facts:

\begin{itemize}

   \item \code{inactive(node A)}: Fact present on nodes that are not currently
      running on a thread. Facts \code{running(T, A)} and \code{inactive(A)} are
      mutually exclusive.

   \item \code{owner(node A, thread T)}: Fact that indicates the current thread
      \code{T} that currently owns node \code{A}.

   \item \code{available-work(node A, bool F)}: Fact that indicates if node
      \code{A} has new facts to be processed.

\end{itemize}

In terms of thread facts we have the following:

\begin{itemize}
   \item \code{active(thread T)}: Fact exists if thread \code{T} is currently
      active.

   \item \code{idle(thread T)}: Fact exists if thread \code{T} is currently
      idle. Facts \code{idle(T)} and \code{active(T)} are mutually exclusive.
\end{itemize}

Figure~\ref{code:threads:modeling} presents how the operational semantics for a
given LM program is modeled using the LM language itself.

\begin{figure}[h!]
\begin{Verbatim}[numbers=left,fontsize=\codesize,commandchars=*\#\&]
type linear running(thread, node). type linear inactive(node).
type linear priority(node, float). type linear default-priority(node, float).
type linear available-work(node, bool).
type linear active(thread).  type linear idle(thread).
type linear owner(node, thread).

owner(A, T). // Initially node assignment.
available-work(A, true). // All nodes have available work.

active(T). // All threads are active.

// Program rules go here.
node-fact(A, X, Y),
other-fact(A, X, B),
priority(A, PA), priority(B, PB),
owner(B, TB), running(T, A),
available-work(B, _)
   -o remote-fact(B), local-fact(A),
      owner(B, TB), running(T, A),
      priority(A, PA), priority(B, PB),
      available-work(B, true).

// Node switching has lower priority.
active(T), running(T, A), priority(A, Prio),
default-priority(A, DefPrio), available-work(A, T),
   -o inactive(A), priority(A, DefPrio),
      default-priority(A, DefPrio),
      available-work(A, false), idle(T).

// Select next node to be processed.
[max => Prio |
   idle(T), owner(A, T),
   priority(A, Prio), available-work(A, true)]
   -o active(T), owner(A, T),
      running(T, A), available-work(A, true),
      priority(A, Prio).

// Attempt to steal a node.
idle(T), !other-thread(T, Other)
owner(A, Other), inactive(A),
available-work(A, true)
   -o idle(T), owner(A, T),
      inactive(A), available-work(A, true).
\end{Verbatim}
\caption{Modeling the operational semantics as a LM program.}
\label{code:threads:modeling}
\end{figure}


\subsection{Scheduling}

\begin{figure}[h!]
\begin{Verbatim}[numbers=left,fontsize=\codesize,commandchars=*\#\&]
type linear static(node).  type linear moving(node).
type linear set-priority(node, float).
type linear set-default-priority(node, float).
type linear just-moved(node). type linear move-to-thread(node, thread).

moving(A). // All nodes can be stolen.
inactive(A). // Nodes are not being processed initially.

// Priority facts.
priority(A, initial-priority).
default-priority(A, initial-priority).

schedule-next(A), running(T, A)
   -o running(T, A), set-priority(A, +00).

running(T, A), set-priority(A, P1),
priority(A, P2), P2 < P1
   -o running(T, A), priority(A, P1).

running(T, A), set-priority(A, P1),
priority(A, P2), P2 >= P1
   -o running(T, A), priority(A, P2).

running(T, A), set-default-priority(A, P1),
default-priority(A, P2), P2 < P1
   -o running(T, A), default-priority(A, P1).

running(T, A), set-default-priority(A, P1),
default-priority(A, P2), P2 >= P1
   -o running(T, A), default-priority(A, P2).

running(T, A), set-thread(A, T),
available-work(A, _)
   -o available-work(A, true),
      move-to-thread(A, T).

move-to-thread(A, T2),
running(T, A), owner(A, T),
moving(A), active(T)
   -o idle(T), inactive(A),
      owner(A, T2), static(A),
      just-moved(A).
\end{Verbatim}
\caption{Modeling the operational semantics for coordination facts as a LM program.}
\label{code:threads:modeling_scheduling}
\end{figure}
