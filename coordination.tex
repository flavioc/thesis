As already explained in Chapter~\ref{chapter:implementation}, the set of nodes
of an LM program is seen as a graph data structure $G = (V, E)$ with nodes $V$
and edges $E$ where threads $T$ perform work. Our implementation also allows
threads to steal nodes from other threads in order to improve scalability.
However, there are many scheduling details that are left undefined. How should a
thread schedule the computation of its sub-graph? Is node stealing beneficial to
all programs? What is the best sub-graph partitioning for a given LM program?
The answer to all these questions is \emph{coordination}, a mechanism that we
introduce to allow the programmer to specify custom scheduling and node
partitioning policies. This is an important functionality because LM uses linear
logic and thus the order in which nodes are scheduled can impact the performance
and even the results of the program.

\section{Rationale}\label{section:coord:rationale}

\input{coordination/rationale}

\section{Types of Facts}

\input{coordination/types}

\section{Scheduling Facts}\label{sec:coord:fifo}

\input{coordination/scheduling}

\section{Partitioning Facts}
\input{coordination/partitioning}

\section{Global Directives}

We also provide a few global coordination statements that cannot be specified
as sensing or action facts but are still important:

\begin{itemize}

   \item \texttt{priority @order ORDER.} \texttt{ORDER} can be either
      \texttt{asc} or \texttt{desc}. This defines if node's are to be selected
      by the smallest or the greatest priority, respectively.

   \item \texttt{priority @initial P.} The \texttt{initial} statement informs
      the runtime system that all nodes must start with priority $P$.
      Alternatively, the programmer can define an \texttt{set-priority(A, P)}
      axiom.

\end{itemize}

\section{Coordinating SSSP}
\input{coordination/coord_sssp}

\section{Implementation}
\input{implementation/coord}

\section{Applications}

\input{coordination/programs}

\section{Related Work}
\input{coordination/related_work}
\section{Chapter Summary}

In this chapter we presented the current set of coordination directives,
implemented as sensing and action facts. The use of such facilities allows the
programmer to write derivation rules that change how the runtime system
schedules computation thus improving the executing time and possibly the final
program results. As future work, we intend to extend the set of available
directives and write additional programs using coordination.

