Now that we have presented the coordination facts for LM, we are now in a
position to use them in the SSSP program presented before.  The coordinated
version of the SSSP presented in Fig.~\ref{code:shortest_path_program_coord}
uses the coordination fact \code{set-priority} (line~\ref{line:coord:sssp_set})
and a global program directive to order priorities in ascending order
(line~\ref{line:coord:sssp_asc}).

When run with one thread, the algorithm behaves like Dijkstra's shortest path
algorithm~\cite{Dijkstra}. When using multiple threads, each thread will pick
the shortest distance from their subset of nodes. While this does not yield the
optimal program with relation to 1 thread, it allows for parallel execution and
locally avoids unnecessary work. The result scales well and it is close to
Dijkstra's algorithm.

\begin{figure}[ht]
\begin{Verbatim}[numbers=left,commandchars=\\\{\},fontsize=\scriptsize]
type edge(node, node, int).\hfill// Predicate declaration.
type linear shortest(node, int, list int).
type linear relax(node, int, list int).

\underline{priority @order asc}.\label{line:coord:sssp_asc}

shortest(A, D1, P1), D1 > D2, relax(A, D2, P2)\hfill// Rule 1: newly improved path.
   -o shortest(A, D2, P2),
      \{B, W | !edge(A, B, W) -o
         relax(B, D2 + W, P2 ++ [B]),
         \underline{set-priority(B, float(D2 + W))}\}.\label{line:coord:sssp_set}

shortest(A, D1, P1), D1 <= D2, relax(A, D2, P2)\hfill// Rule 2: longer path.
   -o shortest(A, D1, P1).

shortest(A, +00, []).\hfill// Initial facts.
relax(@1, 0, [@1]).
\end{Verbatim}
   \caption{Shortest Path Program coordinated with \code{set-priority}.}
   \label{code:shortest_path_program_coord}
\end{figure}

Figure~\ref{fig:coordination:new_sssp} presents the 4 steps of computation for
the new SSSP program when executing with 1 thread. In every step a new shortest
path is computed at a different node, starting from the shorter paths up to
the longer paths. This is exactly the same behaviour as the Dijkstra's
algorithm.

\begin{figure}
\begin{center}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord1}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord2}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord3}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord4}
      \caption{}
   \end{subfigure}
\end{center}
\caption{Graphical representation of the new SSSP program. (a) represents the
   program after propagating initial distance at node \code{@1}, followed by
   (b) where the first rule is applied in node \code{@3}. (c)
   represents the result after retracting all the \code{relax} facts at node
   \code{@2} and (d) is the final state of the program where all the shortest paths
   have been computed.}
\label{fig:coordination:new_sssp}
\end{figure}

In order to experiment with the coordinated SSSP program, we extend it to
support the computation of shortest distances from multiple sources. This
modified version was already used in
Section~\ref{section:implementation:performance} for measuring the performance
of LM's VM. MSSD is not only more interesting than SSSP but also allows us to do
a performance comparison.

Figure~\ref{fig:coordination:results_sssp} shows the comparison between the
regular version (without coordination) and the coordinated version. We use the
datasets already described in Section~\ref{section:implementation:performance}.
In each plot we present the following lines: \textbf{Regular}, which represents
the run time of the regular version; \textbf{Coordinated}, which represents the
run time of the coordinated version; \textbf{Regular(1)/Coordinated(t)}, which
represents the speedup of the coordinated version when using the run time of the
regular version using 1 thread; and \textbf{C++}, which is the line representing
the run time of the MSSD C++ program.

Overall, there is a clear improvement in almost every dataset used. The datasets
that see the best results are Twitter, Orkut and LiveJournal, which are the
datasets where the distance is calculated form only a few nodes. When
calculating the distance from multiple sources, the \code{set-priority} fact
is less effective because, although it selects the node with the shortest
distance, other distances to other nodes are also propagated, which may not be
optimal. To solve this particular issue, another kind of priority would have to
be devised in order to prioritize the computation of the shortest distance to
only a single node, which is not supported in our framework.

\begin{figure}[]
        \centering
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-email.png}
                \label{fig:coordination:coord_sssp_email}
                \caption{Graph with 265000 nodes and 420000 edges. The shortest
                distance is calculated for 100 nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-oclinks.png}
                \label{fig:coordination:coord_sssp_oclinks}
                \caption{Graph with around 2000 nodes and 20000 edges. The shortest
                   distance is calculated for all nodes.}
        \end{subfigure} \\
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-twitter.png}
                \label{fig:coordination:coord_sssp_twitter}
                \caption{Graph with 81306 nodes and 1768149 edges. The shortest
                   distance is calculuated for 40 nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-uspowergrid.png}
                \label{fig:coordination:coord_sssp_uspowergrid}
                \caption{Graph with around 5000 nodes and 13000 edges. The
                shortest distance is calculated for all nodes.}
        \end{subfigure}\\
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-orkut.png}
                \label{fig:coordination:coord_sssp_orkut}
                \caption{Graph with 3072441 nodes and 117185083 edges. The shortest
                   distance is calculated for two nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-livejournal.png}
                \label{fig:coordination:coord_sssp_livejournal}
                \caption{Graph with around 4847571 nodes and 68993773 edges. The
                shortest distance is calculated for two nodes.}
        \end{subfigure}\\

        \caption{Scalability for the MSSD program. The LM system scales better
        when there is more work to do per node, with the US Power Grid dataset being the
        most scalability.}

        \label{fig:coordination:results_sssp}
\end{figure}

There is another interesting trend in our results which relates the improvement
offered by the coordination version over the regular version and the number of
threads used. As the number of threads goes up, so does the ratio between the
two versions. This is expected because each thread selects the shortest distance
from its subgraph and not from the whole graph. The best ratios are then seen
when using only a single thread since the sole thread is able to make global
decisions.

\subsection{Proof Of Correctness}

\input{coordination/proof_sssp}
