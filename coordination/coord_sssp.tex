Now that we have presented the coordination facts for LM, we are now in a
position to use them in the SSSP program presented before.  The coordinated
version of the SSSP presented in Fig.~\ref{code:shortest_path_program_coord}
uses the coordination fact \code{set-priority} (line~\ref{line:coord:sssp_set})
and a global program directive to order priorities in ascending order
(line~\ref{line:coord:sssp_asc}).

When run with one thread, the algorithm behaves like Dijkstra's shortest path
algorithm~\cite{Dijkstra}. When using multiple threads, each thread will pick
the shortest distance from their subset of nodes. While this does not yield the
optimal program with relation to 1 thread, it allows for parallel execution and
locally avoids unnecessary work. The result scales well and it is close to
Dijkstra's algorithm.

\begin{figure}[ht]
\begin{Verbatim}[numbers=left,commandchars=\\\{\},fontsize=\scriptsize]
type edge(node, node, int).\hfill// Predicate declaration.
type linear shortest(node, int, list int).
type linear relax(node, int, list int).

\underline{priority @order asc}.\label{line:coord:sssp_asc}

shortest(A, D1, P1), D1 > D2, relax(A, D2, P2)\hfill// Rule 1: newly improved path.
   -o shortest(A, D2, P2),
      \{B, W | !edge(A, B, W) -o
         relax(B, D2 + W, P2 ++ [B]),
         \underline{set-priority(B, float(D2 + W))}\}.\label{line:coord:sssp_set}

shortest(A, D1, P1), D1 <= D2, relax(A, D2, P2)\hfill// Rule 2: longer path.
   -o shortest(A, D1, P1).

shortest(A, +00, []).\hfill// Initial facts.
relax(@1, 0, [@1]).
\end{Verbatim}
   \caption{Shortest Path Program coordinated with \code{set-priority}.}
   \label{code:shortest_path_program_coord}
\end{figure}

Figure~\ref{fig:coordination:new_sssp} presents the 4 steps of computation for
the new SSSP program when executing with 1 thread. In every step a new shortest
path is computed at a different node, starting from the shorter paths up to
the longer paths. This is exactly the same behaviour as the Dijkstra's
algorithm.

\begin{figure}
\begin{center}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord1}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord2}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord3}
      \caption{}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \includegraphics[width=\textwidth]{figures/sssp/coord4}
      \caption{}
   \end{subfigure}
\end{center}
\caption{Graphical representation of the new SSSP program. (a) represents the
   program after propagating initial distance at node \code{@1}, followed by
   (b) where the first rule is applied in node \code{@3}. (c)
   represents the result after retracting all the \code{relax} facts at node
   \code{@2} and (d) is the final state of the program where all the shortest paths
   have been computed.}
\label{fig:coordination:new_sssp}
\end{figure}

\subsection{Experimental Results}

In order to experiment with the coordinated SSSP program, we extend it to
support the computation of shortest distances from multiple sources. This
modified version was already used in
Section~\ref{section:implementation:performance} for measuring the performance
of LM's VM. MSSD is not only more interesting than SSSP but also allows us to do
a performance comparison.

Figure~\ref{fig:coordination:results_sssp}

\begin{figure}[]
        \centering
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-email.png}
                \label{fig:coordination:coord_sssp_email}
                \caption{Graph with 265000 nodes and 420000 edges. The shortest
                distance is calculated for 100 nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-oclinks.png}
                \label{fig:coordination:coord_sssp_oclinks}
                \caption{Graph with around 2000 nodes and 20000 edges. The shortest
                   distance is calculated for all nodes.}
        \end{subfigure} \\
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-twitter.png}
                \label{fig:coordination:coord_sssp_twitter}
                \caption{Graph with 81306 nodes and 1768149 edges. The shortest
                   distance is calculuated for 40 nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-uspowergrid.png}
                \label{fig:coordination:coord_sssp_uspowergrid}
                \caption{Graph with around 5000 nodes and 13000 edges. The
                shortest distance is calculated for all nodes.}
        \end{subfigure}\\
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-orkut.png}
                \label{fig:coordination:coord_sssp_orkut}
                \caption{Graph with 3072441 nodes and 117185083 edges. The shortest
                   distance is calculated for two nodes.}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{\plotsize\textwidth}
                \includegraphics[width=\textwidth]{experiments/coordination/cmp-shortest-livejournal.png}
                \label{fig:coordination:coord_sssp_livejournal}
                \caption{Graph with around 4847571 nodes and 68993773 edges. The
                shortest distance is calculated for two nodes.}
        \end{subfigure}\\

        \caption{Scalability for the MSSD program. The LM system scales better
        when there is more work to do per node, with the US Power Grid dataset being the
        most scalability.}

        \label{fig:coordination:results_sssp}
\end{figure}

\subsection{Proof Of Correctness}

The most interesting property of the SSSP program presented in
Fig.~\ref{code:shortest_path_program_coord} is that it remains provably correct,
although it applies rules using a smarter ordering. We now show the complete
proof of correctness.

\begin{invariant}[Distance]

\code{relax(A, D, P)} represents a valid distance \code{D} and a valid path
\code{P} from node \code{@1} to node \code{A}. If the shortest distance to
\code{@1} is $D'$, then $D >= D'$.

\code{shortest(A, D, P)} represents a valid distance \code{D} and a valid
path \code{P} from node \code{@1} to node \code{A}. If the shortest
distance to \code{@1} is $D'$, then $D >= D'$. The \code{shortest} fact may
also represent an invalid distance if \code{D = +00}, where \code{P = []}.

\end{invariant}

\begin{proof}
By mutual induction. All the initial facts are valid and rule 1 and 2 validate the
invariant using the inductive hypothesis.
\end{proof}

\begin{lemma}[Relaxation]
Every new improved distance will be propagated to the neighbor nodes exactly once.
\end{lemma}
\begin{proof}
By rule 1, we know that when the distance is relaxed, we keep the new shorter
distance and propagate the distances. Every new distance that is longer will be
ignored by rule 2.
\end{proof}

\begin{theorem}[Correctness]

   Assume a graph $G = (V, E)$ where $W_{e \in E) >= 0}$ (positive weights).
   Consider that there is a set of nodes $S \in V$ where the shortest distances
   has been computed and a set $U \in V$ where it has not yet been reached.
   Sets are $S$ and $U$ are disjunct. At any given point, $\Sigma$ is the sum of
   all current shortest distances. For the distance \code{+00} we assign the
   value $\Sigma' + 1$, where $\Sigma'$ is the sum of the true shortest
   distances of nodes reachable from \code{@1}.  Every rule inference will
   either:

   \begin{itemize}
      \item Maintain the size of $S$ and reduce the total number of facts in
         the database.
      \item Increase the size of $S$, reduce $\Sigma$ and potentially increase the number of
         facts in the database.
      \item Maintain the size of $S$, decrease $\Sigma$
         and potentially increase the number of facts in the database.
   \end{itemize}

   Eventually, set $S = V$ and every \code{shortest(A, D, P)} will represent
   the shortest distance from \code{A} to \code{@1} and \code{P} is its
   corresponding path.
\end{theorem}

\begin{proof}
   By nested induction on $\Sigma$ and on the number of facts in the database.

   In the base case, we have \code{relax(@1, 0, [@1])} that will give us
   the shortest distance for node \code{@1}, therefore $S = \{@1\}$ and
   $\Sigma$ is reduced.

   In the inductive case, we have a set $S'$ where the shortest distance was
   reached and \code{relax} distances may have been propagated (Relaxation
   Lemma).

   Now consider the two rules of the program:

   \begin{itemize}

      \item Rule 1 will only apply at nodes in $U$. If the shortest
         \code{relax} is selected, then the node is added to $S$, otherwise it
         stays in $U$ but improves the shortest path, reduces $\Sigma$ and
         \code{relax} facts are generated (Relaxation Lemma).

      \item Rule 2 is applied in either nodes of $S$ or $U$. For both sets, the rule
         retracts the \code{relax} fact.

   \end{itemize}

   The case where rule 1 derives the true shortest distance happens when the
   node that minimizes $\argmin_t d(s \in S) + w(s, t)$ is selected, where
   $d(x)$ is the distance to the node \code{@1} and $w(a, b)$ the weight of
   the edge between $a$ and $b$. Using \code{set-priority} increases the
   probability of that node being selected, but it does not matter since
   the program always makes progress and the shortest distances will be
   eventually computed.
\end{proof}
