This chapter provides an overview of the proof theoretic basis behind LM and the
dynamic semantics of the language. First, we will present the subset of linear
logic on which LM is built. Second, we present the high level dynamic semantics
- how rules are evaluated and node communication - followed by the low level
dynamics, a close representation of how the virtual machine runs. We prove that
the low level dynamic semantics are sound in relation to the high level dynamic
semantics. However, the low level dynamic semantics are not complete due to the
presence of rule priorities, comprehensions and aggregates, which are features
that are not represented directly by the underlying linear logic system.  This
approach has been used in Prolog, which includes useful features such as the
\emph{cut operator} and a depth-first search strategy that make the language
sound but not complete.

\section{Linear Logic}
\input{logic/linear_logic}

\section{High Level Dynamic Semantics}

\input{hld}

\section{Low Level Dynamic Semantics}
\input{lld}
\section{Soundness Proof}
\input{lld/soundness}
\section{Related Work}
\input{logic/related_work}
\section{Chapter Summary}

In this chapter we presented the proof theoretic foundations of LM.  First, we
introduced the sequent calculus of the linear logic fragment that supports LM. We then
presented HLD, the high level dynamic semantics that was created by interpreting
the linear logic fragment using focusing and chaining. Next, we designed LLD,
an abstract machine for the operational semantics that mimics the execution of
rules in our virtual machine minus small details.  Finally, we proved that LLD is sound
in relation to HLD, thus showing a connection from LLD to the linear logic
fragment.

