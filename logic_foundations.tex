This chapter provides an overview of the proof theoretic basis behind LM
and the dynamic semantics of the language. First, we will present the subset of
linear logic from which LM is built on. Second, we present the high level
dynamic semantics - how rules are evaluated and node communication - followed by
the low level dynamics, a close representation of how the virtual machine runs.
Finally, we prove that the low level dynamic semantics are sound in relation to
the high level dynamic semantics.

\section{Linear Logic}

Logic, as \emph{classically} understood, treats true propositions as
\emph{persistent truth}. When a persistent proposition is needed to prove other
propositions, it can be reused as many times as we wish because it is true
indefinitely. This is also true in the \emph{constructive} or
\emph{intuitionistic} school of logic.  Linear logic is a \emph{substructural
logic} (lacks weakening and contraction) developed by
Girard~\cite{Girard95logic:its} extends \emph{persistent logic} with linear
propositions which can be understood as ephemeral resources that can be used
only once to prove other propositions.  Naturally, linear logic is well
suited for modeling computing systems that deal with state, of which LM is
one of them.  Traditional forward-chaining logic programming languages like
Datalog only use persistent logic, however many ad-hoc
extensions~\cite{Liu98extendingdatalog,Ludascher95alogical} have been devised
in to support state updates, but most are extra-logical which makes it harder
to reason about programs. LM uses linear logic as its foundation, therefore
state updates are natural to the language.

In linear logic, truth is treated as a resource that is consumed once used. For
instance, in the graph visit program in Fig.~\ref{code:visit}, the
\texttt{unvisited(A)} and \texttt{visit(A)} linear facts are consumed in order
to prove \texttt{visit(A)} and the comprehension. If those facts were
persistent, then the rule would make no sense, because the node would be
\texttt{visited} and \texttt{unvisited} at the same time!

\subsection{Sequent calculus of \fragment}

\input{sequent_calculus}

\subsection{From the \fragment sequent calculus to LM}


\begin{table*}
\begin{center}
\resizebox{16cm}{!}{
    \begin{tabular}{ | l | l || l | l | l |}
    \hline
    Connective                   & Description                                      & LM Syntax                                  & LM Place     & LM Example                                  \\ \hline \hline
    $\emph{fact}(\hat{x})$       & Linear facts.                                    & $fact(\hat{x})$                               & Body or Head    & \texttt{path(A, P)}                            \\ \hline
    $\bang \emph{fact}(\hat{x})$ & Persistent facts.                                & $\bang fact(\hat{x})$                         & Body or Head    & \texttt{$\bang$edge(X, Y, W)}                  \\ \hline
    $1$                          & Represents rules with an empty head.             & $1$                                           & Head            & \texttt{1}                                     \\ \hline
    $A \otimes B$                & Connect two expressions.                         & $A, B$                                        & Body and Head   & \texttt{path(A, P), edge(A, B, W)}             \\ \hline
    $\forall x. A$               & To represent variables defined inside the rule.  & Please see $A \lolli B$                       & Rule            & \texttt{path(A, B) $\lolli$ reachable(A, B)}   \\ \hline
    $\exists x. A$               & Instantiates new node variables.  & $\existsc{\widehat{x}}{B}$                  & Head            & \texttt{exists A.(path(A, P))}                 \\ \hline
    $A \lolli B$                 & $\lolli$ means "linearly implies".               & $A \lolli B$                                  & Rule            & \texttt{path(A, B) $\lolli$ reachable(A, B)}   \\
                                 & $A$ is the body and $B$ is the head.             &                                               &                 &                                                \\ \hline
    $\iters{name}{\widehat{V}}$               & For comprehensions
    ($\widehat{V}$ is empty).  & $\comprehension{\widehat{x}}{A}{B}$  & Head            & \texttt{\{B | !edge(A, B) | visit(B)\}}        \\
                                 & For aggregates ($\widehat{V}$ accumulates).          &                                               &                 &                                                \\ \hline
    \end{tabular}
}
\end{center}
\caption{Connectives from \fragment and their use in LM.}
\label{table:linear}
\end{table*}

The connections between LM and \fragment presented in the previous section
are somewhat obvious. We summarize the connection connectives of the system and
the LM syntax in Table~\ref{table:linear}. As an example, we translate the
abstract syntax of the first rule of the graph visit program shown
in~\ref{visit:ast} to a proposition in \fragment:

\begin{align}
\forall_A. (\mathtt{visit}(A) \otimes \mathtt{unvisited}(A) \lolli
   \mathtt{visited}(A) \otimes \itersz{comp} A)
\end{align}

The translation is fairly straightforward, except for the comprehension. Each
comprehension of a LM program must be assigned to an unique name and its
corresponding terms. For the iterative definition $comp$, it is defined as
following:

\begin{align}
\iterz{comp}{0} A & \defeq \one\\
\iterz{comp}{N} A & \defeq \forall_B.((\bang \mathtt{edge}(A, B) \lolli
\mathtt{visit}(B)) \otimes \iterz{comp}{N-1} A)
\end{align}

Notice that the argument list of the iterative definition is being used
to pass around terms from outside the definition, in this case, the variable
$A$. However, the argument list can also be used to implement aggregates.
Recall the aggregate example shown before:

{\small
\begin{Verbatim}
count-prices(A) -o [sum => P | . | price(A, P) | 1 | total(A, P)].
\end{Verbatim}
}

This rule is translated into a linear logic proposition as shown next:

\begin{align}
\forall A. (\mathtt{count-prices}(A) \lolli \iters{agg} A \; 0)
\end{align}

The iterative definition $\mathtt{agg}$ is defined as follows:

\begin{align}
\iterz{agg}{0} A \; P' & \defeq \mathtt{total}(A, P') \\
\iterz{agg}{N} A \; P' & \defeq \forall_P. ((\mathtt{price}(A, P) \lolli \one)
      \otimes \iterz{agg}{N-1} A \; (P' + P))
\end{align}

\section{High Level Dynamic Semantics}

\input{hld}

\section{Low Level Dynamic Semantics}
\input{lld}
\section{Soundness Proof}
\input{lld/soundness}
\section{Summary}

In this chapter we presented the proof theoretic foundations of LM.  First, we
introduced \fragment, the linear logic fragment that supports LM. We then
presented HLD, the high level dynamic semantics that was created by interpreting
the linear logic fragment using focusing and chaining. Next, we designed LLD,
the low level dynamic semantics that mimics the execution of rules in our
virtual machine minus small details.  Finally, we proved that LLD is sound
in relation to HLD, thus showing a connection from LLD to \fragment.

