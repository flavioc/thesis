
Linear Meld (LM) is a forward chaining logic programming language in the style
of Datalog~\cite{Ullman:1990:PDK:533142}. An LM program is defined by a
\emph{database of facts} and by a set of \emph{derivation rules}.  Initially, we
populate the database with the program's initial facts and then determine which
derivation rules can be applied by using the current database. Once a rule is
applied, we derive new facts, which are then added to the database.  If a rule
uses linear facts, they are consumed and thus deleted from the database.  The
program stops when we reach \emph{quiescence}, that is, when we can no longer
obtain new facts through rule derivation.

LM departs from Datalog by making the database of facts a graph data structure
where each node contains the fraction of the database representing the facts
associated with or belonging to the node. Derivation rules are then restricted
so that they are only allowed to manipulate facts belonging to the same node.
This restriction allows multiple nodes of the graph to perform independent rule
derivations at the node level, thus introducing concurrency in the program.
Communication between nodes arises when a derivation rule derives a fact that
belongs to another node.

\section{A Taste Of LM}

In order to understand how LM programs are written, we now present and discuss
three elementary LM programs.

\subsection{First Example: Message Routing}\label{section:language:message}
\input{language/message_routing}

\subsection{Second Example: Key/Value Dictionary}\label{sec:language:key_value}
\input{language/key_value}

\subsection{Third Example: Graph Visit}
\input{language/graph_visit}

\section{Types and Locality}

Each fact is an association between a \emph{predicate} and a tuple of values. A
predicate is a pair with a name and a tuple of types (the argument types). LM
rules are type-checked using the predicate declarations in the header of the
program. LM has a simple type system that includes the following simples types:
\emph{node}, \emph{int}, \emph{float}, \emph{string}, \emph{bool}. The following
structured types are also supported: \emph{list} $X$, for lists of type $X$;
\emph{struct} $X_1, \ldots, X_n$, for composite values made of $n$ elements; and
\emph{array} $X$, for arrays of type $X$.

LM allows the definition of new type names from simpler types using the declaration
\code{type simple-type new-type} in the header of the program. The type
\code{new-type} can then be used as any other type. Note that LM uses
\emph{structural equivalence} to check if two types are the same, therefore
\code{simple-type} and \code{new-type} are type equivalent.

Type checking LM programs is straightforward due to its simple type system and
mandatory predicate declarations. For each rule, the variables found in the LHS
are mapped to types based on their use on atomic proposition arguments. Some
constraints of the form \code{X = expression} that force an equality between
\code{X} and \code{expression} may actually represent an assignment of
\code{expression} to \code{X} since \code{X} may not be used in any proposition
argument. In this case, all the variables in \code{expression} must be typed or
else \code{X} becomes an \emph{undefined variable}. Variables in the rule's RHS
must be defined in the LHS, because otherwise derived facts would not be
\emph{ground}, that is, some arguments would be undefined or uncomputable.  For
comprehensions and aggregates, type checking is identical, however, the LHS of
each construct must document the variables in scope using the $\hat{x}$
argument. If a variable is introduced in the LHS that is not in $\hat{x}$, type
checking will fail.

Another important component of type checking is \emph{locality checking}. The
first argument of each atomic proposition in the LHS must use the same variable
in order to enforce locality and allow concurrency. This \emph{home variable} is
always typed as a \emph{node} and represents a node in the program's graph. In
the rule's RHS, other home variables are allowed, as long as they are defined
variables. For comprehensions and aggregates, the LHS must use the same home
argument as the rule's LHS.

\section{LM Syntax}
\input{language/syntax}
\section{Applications}
\input{language/applications}

\section{Related Work}\label{section:language:related}
\input{language/related_work}
\section{Chapter Summary}

In this chapter, we gave an overview of the LM language, including its syntax
and operational semantics. We also explained how to write programs using all the
facilities provided by LM, including linear facts, comprehensions, and
aggregates. We also explained how to informally prove the correctness of several
LM programs.
