The Quick-Sort algorithm is a divide and conquer sorting algorithm that works by
splitting a list of items into two sublists and then recursively sorting the two
sublists. To split the list, it picks a pivot element and puts the items that are
smaller than the pivot into the first sublist and the items greater than the pivot
into the second list.

The Quick-Sort algorithm is interesting because it does not map immediately to
the graph-based model of LM. Our approach considers that the program starts with
a single node where the initial list is located. Then the list is split as usual
and two nodes are created that will recursively sort the sublists.
Interestingly, this creates a tree that will look similar to a call tree in a
functional programming language.

Figure~\ref{language:code:quicksort} presents the code for the quick-sort
algorithm in LM. For each sublist, we start with a \code{down} fact that later
must be, eventually, transformed into an \code{up} fact with the sublist sorted.
In line~\ref{line:language:qs_axiom} we start with the initial list at node
\code{@0}. If the list has a small number of items (two or less), then rules at
lines~\ref{line:language:qs_small1}-\ref{line:language:qs_small2} will
immediately sort it, otherwise the rule in line~\ref{line:language:qs_complex}
is applied to split the list in 2 sublists. The fact \code{split} first splits
the list using the pivot \code{Pivot} using rules in
lines~\ref{line:language:qs_split1}-\ref{line:language:qs_split2}.  When there
is nothing else to split, the rule in
lines~\ref{line:language:qs_exists1}-\ref{line:language:qs_exists2} uses an
exists construct to create nodes \code{B} and \code{C} and then the sublists are
sent to nodes \code{B} and \code{C} using \code{down} facts.  \code{back} facts
are also derived to be used to send the sorted list back to the parent node
using the rule in line~\ref{line:language:qs_back}.

When two sublists are sorted, two \code{sorted} facts are derived that must be
matched against \code{waitpivot} in the rule in
lines~\ref{line:language:qs_sorted1}-\ref{line:language:qs_sorted2}. The sorted
sublists are appended and send \code{up} to the parent node via the derivation
of an \code{up} fact (line~\ref{line:language:qs_up}).

\begin{figure}[h!]
\begin{Verbatim}[numbers=left,fontsize=\codesize,commandchars=\*\{\}]
type linear back(node, node).*hfill// Predicate declaration.
type linear down(node, list int).
type linear up(node, list int).
type linear sorted(node, node, list int).
type linear split(node, int list int, list int, list int).
type linear waitpivot(node, int, node, node).

down(A, []) -o up(A, []).*label{line:language:qs_small1}*hfill// Rule 1: empty list.

down(A, [X]) -o up(A, [X]).*hfill// Rule 2: single element list.

down(A, [X, Y]), X < Y -o up(A, [X, Y]).*hfill// Rule 3: two element list.

down(A, [X, Y]), X >= Y -o up(A, [Y, X]).*label{line:language:qs_small2}*hfill// Rule 4: two element list.

down(A, [Pivot | Xs])*label{line:language:qs_complex}*hfill// Rule 5: lists with more than two elements.
   -o split(A, Pivot, Xs, [], []).

split(A, Pivot, [], Smaller, Greater) -o*label{line:language:qs_exists1}*hfill// Rule 6: create nodes to sort sublists.
   exists B, C. (back(B, A), back(C, A),
                 down(B, Smaller), down(C, Greater), waitpivot(A, Pivot, B, C)).*label{line:language:qs_exists2}

split(A, Pivot, [X | Xs], Smaller, Greater), X <= Pivot*label{line:language:qs_split1}*hfill// Rule 7: split case 1.
   -o split(A, Pivot, Xs, [Y | Smaller], Greater).

split(A, Pivot, [X | Xs], Smaller, Greater), X > Pivot*hfill// Rule 8: split case 2.
   -o split(A, Pivot, Xs, Smaller, [Y | Greater]).*label{line:language:qs_split2}
   
waitpivot(A, Pivot, NodeSmaller, NodeGreater),*label{line:language:qs_sorted1}*hfill// Rule 9: merge sublists.
sorted(A, NodeSmaller, Smaller),
sorted(A, NodeGreater, Greater)
   -o up(A, Smaller ++ [Pivot | Greater]).*label{line:language:qs_sorted2}*label{line:language:qs_up} // Append the lists.

up(A, L), back(A, B) -o sorted(B, A, L).*label{line:language:qs_back}*hfill// Rule 10: send list to parent.

down(@0, initial_list).*label{line:language:qs_axiom}*hfill// Initial facts.
\end{Verbatim}
  \caption{Quick-Sort program written in LM.}
  \label{language:code:quicksort}
\end{figure}

The Quick-Sort program shows that it is possible for applications to manipulate
and change the structure of the graph during run time. This is possible with the
use of the exists construct, which allows the programmer to create new nodes
where facts can be derived. In the case of the Quick-Sort, it allows the program
to create a tree of nodes where sorting can take place concurrently.

The amount of concurrency available in the Quick-Sort program depends on the
quality of the selected pivot. If the pivot splits the list in equal parts, then
there is more concurrency because it is now possible to work on the two halfs of
the list concurrently and those halfs have the same size. If a bad pivot is
selected, then we may end up in situations where the pivot is the smallest (or
largest) element of the list, splitting the list into an empty list and a list
with $n-2$ elements. It is clear that the amount work required the sort the
empty list is much smaller than the work required to sort the larger list.
Repeatly choosing a bad pivot will effectly turn Quick-Sort into a sequential
algorithm. This is not suprising since it is directly related to the
Quick-Sort's average and worst case complexity, $\mathcal{O}(n \log{n})$ and
$\mathcal{O}(n^2)$, respectively.

The proof of correctness for Quick-Sort follows in a different style than what
we have done up to this point. Instead of proving invariants, we prove what
happens to the database given the presence of some logical facts.

\begin{lemma}[Split lemma]

If a \code{split(A, Pivot, L, Small, Great)} fact exists then it will be
consumed and a \code{split(A, Pivot, [], Small' ++ Small, Great' ++ Great)} fact
will be derived, where the elements of \code{Small'} are lesser or equal than \code{Pivot} and
the elements of \code{Great'} are greater than \code{Pivot}.

\end{lemma}
\begin{proof}
By induction on the size of \code{L}.
\end{proof}

\begin{theorem}[Sort theorem]
If a \code{down(A, L)} fact exists then it will be consumed and a \code{up(A,
L')} fact will be derived, where \code{L'} is the sorted list of \code{L}.
\end{theorem}
\begin{proof}
By induction on the size of \code{L}.

The base cases are proven trivially (rules 1-4).

In the inductive case we start with rule 5:
\begin{Verbatim}[fontsize=\codesize]
down(A, [Pivot | Xs]) -o split(A, Pivot, Xs, [], []).
\end{Verbatim}

and necessarily derive \code{split(A, Pivot, Xs, [], [])}. Using the split
lemma, then we get \code{split(A, Pivot, [], Smaller, Greater)}, which leads us
to use the rule 6::

\begin{Verbatim}[fontsize=\codesize]
split(A, Pivot, [], Smaller, Greater) -o
   exists B, C. (back(B, A), back(C, A),
                 down(B, Smaller), down(C, Greater), waitpivot(A, Pivot, B, C)).
\end{Verbatim}

and derive \code{back(B, A)}, \code{back(C, A)}, \code{down(B, Smaller)},
\code{down(C, Greater)} and \code{waitpivot(A, Pivot, B, C)}. The semantics of
LM ensure that \code{B} and \code{C} are fresh node addresses, therefore those
new facts will be derived on nodes with no facts. We know that \code{Smaller}
and \code{Greater} are both smaller (in size) than \code{L}, so, if we use the
induction hypothesis, we get \code{up(B, Smaller')} and \code{up(C, Greater')}.
These last two facts will be applied using the following rule:

\begin{Verbatim}[fontsize=\codesize]
up(A, L), back(A, B) -o sorted(B, A, L).
\end{Verbatim}

thus, generating \code{sorted(A, B, Smaller')} and \code{sorted(A, C,
Greater')}. In the continuation, we can use only the rule that accepts
\code{sorted} and \code{waitpivot} facts:

\begin{Verbatim}[fontsize=\codesize]
waitpivot(A, Pivot, NodeSmaller, NodeGreater),
sorted(A, NodeSmaller, Smaller),
sorted(A, NodeGreater, Greater)
   -o up(A, Smaller ++ [Pivot | Greater]). // Append the lists.
\end{Verbatim}

returning \code{up(A, Smaller' ++ [Pivot | Greater'])}.  We know that
\code{Smaller' ++ [Pivot | Greater']} is sorted since \code{Small'} contains the
sorted list of elements lesser or equal than \code{Pivot} and \code{Greater'}
the elements greater than \code{Pivot}.

\end{proof}

