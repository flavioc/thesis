This chapter describes the multicore implementation of the LM language,
including its compiler, supporting runtime and parallelism. We first start with
an overview of the implementation in order to understand how all pieces of the
implementation fit together. Secondly, we describe how parallelism is achieved,
including its data structures and thread scheduling. Thirdly, we present the
implementation details of coordination and how it relates with parallelism.  We
then describe the runtime and data structure used to implement nodes and the
database of facts, followed by the compilation algorithm used by our compiler to
turn logical rules into efficient C++ code.

\section{Overview}
\input{implementation/overview}

\section{Parallelism}\label{sec:implementation:parallelism}
\input{implementation/parallelism}

\section{Node Data Structure}\label{sec:data_structures}
\input{implementation/node}

\subsection{Communication}

At this point, we can now summarize the main thread synchronization hotspots in the
virtual machine. Threads synchronize with each other using mutual exclusion. We
use a spin-lock in the work queue to protect queue operations.  Given threads $T_1$
and $T_2$, we enumerate the most important synchronization hotspots:

\begin{itemize}

   \item \textbf{New facts}: When a node executes in $T_1$ and derives facts to
   a node in $T_2$, $T_1$ first buffers the facts and then sends them to the
   target node. Here, it checks if the node is currently \textbf{idle} and then
   synchronizes with $T_2$ to add the node to the $T_2$'s queue.  If $T_2$ is
   inactive  then $T_1$ also synchronizes with $T_2$ to change $T_2$'s state to
   \emph{active}.

   \item \textbf{Node stealing}: $T_1$ synchronizes with $T_2$ when it attempts
   to steal nodes from $T_2$ by removing half of the nodes from one of $T_2$'s
   queues.

\end{itemize}

\input{implementation/locks}


\section{Memory Allocation}
\input{implementation/allocation}

\section{Compilation}
\input{implementation/comp}

\section{Related Work}
\input{implementation/related_work}

\section{Experimental Evaluation}
\input{implementation/evaluation}

\section{Chapter Summary}

This chapter provided a full description of the implementation of LM, including
its compiler and virtual machine. We explained how the virtual machine is
organized to provide scalable multi threaded execution and fast fact assertion
and retraction using efficient data structures. We also gave a detailed
description of the compilation algorithm used to transform LM rules into
efficient C++ code.
