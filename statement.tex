
We propose a new linear logic programming language, called Linear Meld~(LM),
designed to write \textbf{declarative parallel graph based programs} for
multicore architectures. LM is a novel programming language that makes
\textbf{coordination} a first-class programming construct that is
\textbf{semantically equivalent to computation}. Coordination allows the
programmer to write declarative code that reasons about the underlying parallel
architecture in order to improve the run time and scalability of programs. Since
LM is based on logical foundations, programs are amenable to reasoning, even in
the presence of coordination.

We support our thesis through seven major contributions:

\begin{description}
   
   \item[Linear Logic]

   We integrated linear logic into our language, so that program state can be
   encoded naturally. The original Meld was fully based on classical logic where
   everything that is derived is true forever. Linear logic turns some facts
   into resources that can be consumed when a rule is applied.  To the best of
   our knowledge, LM is the first linear logic based language implementation
   that attempts to solve real world problems.

   \item[Coordination Facts]
   
   LM offers execution control to the programmer through the use of coordination
   facts. These coordination facts change how the runtime system schedules
   computation and partitions data and is semantically equivalent to standard
   computation facts. We used the concept of action facts and sensing facts to
   coordinate the execution of programs. We can increase the priority of certain
   nodes according to the state of the computation and to the state of the
   runtime in order to make better scheduling decisions so that programs can be
   more scalable and run faster.

   \item[Thread-Based Facts]

   While LM can be classified as a programming language with implicit
   parallelism, it introduces thread facts to support some form of declarative explicit
   parallelism. Thread facts allow the programmer to reason about the state of
   the underlying parallel architecture, namely the execution thread, by
   managing facts about each thread. Thread facts can be used along with regular
   facts belonging to nodes and coordination facts, allowing for the
   implementation of customized parallel scheduling algorithms. We show how some
   programs take advantage of this facility to create optimal scheduling
   algorithms that are not possible in the limited context of implicit
   parallelism.
   
   \item[Provability]
   
   We leveraged the logical foundations of LM to show how to prove the correctness
   of programs. We also show that coordination facts do not change those
   correctness proofs but only improve run time, scalability or memory usage. We
   also show how to reason with thread-based facts.

\item[Efficient Runtime and Compilation]

   We have implemented a runtime system with support for efficient data
   structures for handling linear facts and a compiler that is designed to
   transform inference rules into C++ code that make use of those data
   structures. We have achieved a sequential performance that is less than one
   order of magnitude slower than hand-written sequential C++ programs and is
   competitive with some more mature frameworks such as
   GraphLab~\cite{GraphLab2010} or Ligra~\cite{Shun:2013:LLG:2517327.2442530}.

\item[Multicore Parallelism]
   
   The logical facts of the program are partitioned across the graph of the
   nodes. Since the logical rules only make use of facts from a single node,
   computation can be performed locally, independently of other nodes of the
   graph. We view applications as a communicating graph data structure where
   each processing unit performs work on a different subset of the graph, thus
   enabling concurrency. This is an advantage of LM since we can run programs on
   many different types of distributed systems as long as the underlying runtime
   system uses the appropriate communication facilities.

\item[Experimental Results]

   We have implemented a compiler and a virtual machine prototype from scratch
   that executes on multicore machines.  We have implemented programs such as
   belief propagation, belief propagation with residual splash, PageRank, graph
   coloring, N queens, shortest path, diameter estimation, MapReduce, game of
   life, quick-sort, neural network training, among others. Our experiments
   performed on a machine with 32 cores shows that our implementation provides
   good scalability with up to 32 threads of execution.
   
\end{description}
