
We propose Linear Meld (LM), a new linear logic programming language, designed
to write parallel graph based programs on multicores.  We argue that LM is a
superior declarative programming model because it not only automatically
parallelizes programs, but, in cases where it is necessary, it allows the
programmer to control parallel scheduling and placement of data to further
improve the program run time and scalability.  Since LM is based on solid
logical foundations, we argue that we can also prove interesting properties of
programs, including correctness and termination. We will support our thesis
through seven major contributions:

\begin{itemize}
   
   \item Linear Logic

   We integrated linear logic into our language, so that program state can be
   encoded naturally. The original Meld was fully based on classical logic where
   everything that is derived is true forever. Linear logic turns some facts
   into resources that will be consumed when a rule is applied.  To the best of
   our knowledge, LM is the first linear logic based language implementation
   that attempts to solve real world problems.

   % need to talk about thread facts here.

   \item Coordination
   
   LM offers execution control to the programmer through the use of coordination
   facts to make the program faster and more scalable. These coordination facts
   change how the runtime system schedules computation and partitions data and
   is semantically equivalent to standard computation facts.  We used the
   concept of \emph{action facts} and \emph{sensing facts} o coordinate the
   execution of programs.  We can increase the priority of certain nodes during
   runtime according to the state of the computation and to the state of the
   runtime in order to make better scheduling decisions so that programs can run
   faster.

   \item Optional Explicit Parallelism

   While LM can be classified as a programming language with implicit
   parallelism, it introduces thread facts to support optional explicit
   parallelism. Thread facts allow the programmer to reason about the state of
   the underlying parallel architecture, namely the execution thread, by
   managing facts about each thread. Thread facts can be used along with regular
   facts belonging to nodes and coordination facts, allowing for the
   implementation of customized parallel scheduling algorithms. We show how some
   programs take advantage of this facility to create optimal scheduling
   algorithms that are not possible in the limited context of implicit
   parallelism.
   
   \item Provability
   
   Since LM is a logic programming language, we leveraged the logical
   foundations of the language to show how to prove correctness and termination of a few
   programs. We also show that coordination facts do not change those
   correctness proofs of programs but only improve run time, scalability or
   memory usage.


   \item Efficient Runtime and Compilation

   We have implemented a runtime system with support for efficient data
   structures for handling linear facts and a compiler that is designed to
   transform inference rules into C++ code that make use of those data
   structures. We have achieved a sequential performance that is less than one
   order of magnitude slower than hand-written sequential C++ programs and is
   competitive with some frameworks such as GraphLab~\cite{GraphLab2010}.

   \item Multicore Parallelism
   
   We divide the logical facts across all the nodes of the graph. Since the
   logical rules only make use of facts from a node, computation can be
   performed locally, without reference from other nodes of the graph.
   We envision the application as a communicating graph data structure where
   each processing unit performs work on a different subset of the graph, thus
   enabling concurrency. This is an advantage of LM since we can run programs on
   many different types of distributed systems as long as the underlying runtime
   system uses the appropriate communication facilities.

   \item Experimental Results

   We have implemented a compiler and a virtual machine prototype from
   scratch that executes on multicore machines.  We have implemented programs
   such as belief propagation, belief propagation with residual splash,
   PageRank, graph coloring, N queens, shortest path, diameter estimation,
   MapReduce, game of life, quick-sort, neural network training, among others.
   Our experimental results show that our particular implementation provides
   good scalability up to 24 cores.
   
\end{itemize}
