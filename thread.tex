In the previous chapter, we introduced coordination facts, a mechanism that can
be used by the programmer to coordinate execution. While these facilities retain
the implicit parallelism of the language, they do not allow the programmer to
fully reason about the underlying parallel architecture since the only reasoning
allowed relates to node partitioning and data placement. In principle, it should
be advantageous to reason about thread state, that is, to perform rule inference
about facts stored on each thread and allow threads to communicate and
coordinate between them depending on their current state. This introduces a kind
of explicit parallelism into the implicit parallel model of LM.  However, this
explicit parallelism remains declarative so that the programmer is able to
reason about thread coordination as well as regular computation.

\section{Motivating Example: Graph Search}
\input{threads/graph_reachability}

\section{Implementation Changes}
\input{threads/implementation}

\section{Applications}

This section presents more applications that demonstrate the usefulness and
power of thread-based facts.

\subsection{Binary Search Trees: Caching Results}
\input{threads/key_value}

\subsection{PowerGrid Problem}
\input{threads/powergrid}

\subsection{Splash Belief Propagation}\label{sec:coordination:bp}
\input{threads/splash-bp}

\section{Modeling the Operational Semantics in LM}
\input{threads/modeling}

\section{Related Work}
\input{threads/related_work}

\section{Chapter Summary}
\input{threads/summary}
